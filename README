# 线程切换流程

- 线程切换永远都是发生在**内核线程**中，并且在xv6中的每一个CPU scheduler线程，内核线程只能切换到scheduler线程，然后scheduler再切换到另一个内核线程。  
内核线程context保存在p->context中，调度器线程context对象保存再cpu->context中。
- 每一个CPU核在一个时间只会做一件事情，每个CPU核在一个时间只会运行一个线程，要么是用户进程线程，要么是内核线程，要么运行CPU核对应的调度线程。

## 切换

**正在运行的线程切换到另一个RUNABLE但是没有运行的用户空间进程**  
- 定时器中断强制CPU从用户空间进程切换到内核线程，trampoline代码将用户寄存器保存于用户进程对应的trapframe对象中
- 内核运行usertrap，实际执行中断处理程序，此时，CPU正在进程P1的内核线程的内核栈上，执行普通内核中普通的C代码
- 调用swtch函数,保存用户进程P1对应的内核线程的寄存器到context对象中。
- swtch切换至调度线程（读取调度线程寄存器）
- 调度线程切换至进程P2的内核线程，最后返回进程P2用户空间，执行进程P2

## 各类函数

- **yield**：获取进程锁，将进程状态改为RUNABLE，停止使用当前进程栈
- **sched**：检查
- **swtch**：切换函数，保存内核线程context（callee，ra寄存器）
- **scheduler**：调度函数？swtch切换中间站，设置切换进程之间的状态RUNABLE-》RUNNING，调度线程的上下文保存在CPU核的context中

## 小结

- 实验一实现用户级线程切换，实现协程，uthread.c， uthread_switch.S